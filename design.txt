模型

=================================================
前端/后端各服务
=================================================
应用层		化身，事件发布，工作队列，点对点，请求响应等
=================================================
传输层		端点到端点通讯
=================================================
连接层		websocket/tokio channel/http 轮询
=================================================



# 传输层
     消息                  消息
端点 <----> HUB <----> 端点

1. 端点
每个端点代表一个消息的目的地，这个目的地可以是用户，也可以是主题，工作队列等
集群内部对端点应该是透明的。
端点到hub之间的连接：
发送消息是“发送——响应模式”，接受消息为一个流。
1.1 通过websocket的连接
ws是全双工通讯，可以支持这样的模式
1.2 通过tokio channel
发送响应的渠道可以通过 mpsc<oneshot::Sender>
消息流可以通过mpsc通道
1.3 http轮询（optional）
客户端轮询拿到收到的消息
请求/响应发送消息

端点应当和hub保持心跳，当心跳消失，hub通知集群内部端点下线。

2. 消息
一条消息一定是从一个端点到另一个端点，由hub确认消息是否送达，hub返回Ok或者Unreachable

3. 集群
集群里有多个节点，集群之间通过websocket连接。集群内部对于集群外部应当是不可见的。
节点上下线通过k8s或者redis维护（已有实现）
集群应当能够告知端点某个端点是否在线

3.1 连接表
所有已建立连接的端点
端点上线的时候通知所有节点：端点在何处上线
端点下线的时候通知所有节点：端点在何处下线

3.2 路由表
端点所连接的节点的表
路由表也要存连到自身的节点。
路由表在缓存处也要存一份，供节点上线时同步。

集群里有多个节点，pA -> pA, hB -> hB, pA发送消息到pB：
（节点之间是全连接的，也就是说每个节点之间都有一条连接）

首先查路由表：
| ep |  hub   |
|    |        |
| pA |  hA    |
| pB |  hB    |


命中：
1. 进入转发，这个节点在pA和hB之间应视为**透明**
2. 如果转发了一条不可达的消息，删除这条路由信息。

未命中
1. 广播查找pB，要求所有节点响应。
1.1 某个节点hB连接表上命中，响应，并重播端点上线。
1.2 所有节点都响应未命中，返回不可达



# 应用层
运行在node上的端点可以通过tokio的 mpsc<oneshot::Sender>和node通讯
远程用户可以通过websocket和node通讯
对于端点而言，集群内部应当是不可见的，即使端点和node运行在同个程序上。

我们有这么几种端点。（用户和主题是要首先支持的）

1. 用户
远程通过websocket连接到hub上。
前端也应当可以通过Http轮询，来避免一个hub上同时保有过多的连接。
用户一般不知道另一个用户的端点，但是在知道的情况下，点对点的通讯也应当是允许的。
1.1 化身（Avatar）
一个用户可以有多个化身，化身也是一种端点，向化身投递消息会被转发到用户上。
化身内部可以保存其真实用户

一个化身的集合应当可以被简化为一组用户的集合，在投递中防止一个消息被向一个用户投递多次。

资源创建：化身管理员创建。
资源回收：用户或者化身管理员回收。
1.2 化身管理员
管理员有权限为某个用户添加化身
资源创建：管理员创建。
资源回收：管理员回收。

2. 主题（发布/订阅模式）
主题是运行在hub上的虚拟用户，它连接在自己运行的节点上
它接受推送的消息后，向所有订阅它的端点发送消息。
资源创建：有端点订阅的时候创建。
资源回收：如果订阅者为空则回收资源。

2.1 订阅
向主题发送一条订阅消息，主题把该端点加入自己的订阅者中
向主题发送一条取消订阅消息，主题把该端点移出自己的订阅者中
收到端点下线消息，移出订阅者
主题发布消息时如果订阅者不可达，则会被移除。

2.2 发布
向主题发送一条发布消息，主题会把这条消息推送给所有的订阅者中。


3. 工作队列
工作队列是运行在hub上的虚拟用户，它连接在自己运行的节点上
每个工作队列拥有一个消费者队列。消费者需要下一个消息时给hub发一条 fetch 消息，然后工作队列把它加入到消费者队列中。
每当工作队列收到data消息，从消费者队列中拿出一个端点，发送消息。
资源创建：管理员创建
资源回收：管理员回收


4. 服务（请求响应）
Client <----> Hub <----> Server
工作队列是运行在hub上的虚拟用户，它连接在自己运行的节点上
请求响应运行在两个队列上，请求者推送消息到请求队列，从响应队列拿消息发送给对应的请求者。
（在请求响应中，请求和响应者应当互相看不见，只能看到中间的 请求响应 端点）
资源创建：服务发布者创建
资源回收：所有服务提供者下线后回收
